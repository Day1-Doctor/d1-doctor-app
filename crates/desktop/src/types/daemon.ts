// Day 1 Doctor — Daemon WebSocket protocol types (local JSON channel, v1)
// Source of truth: LocalStack_v2.4.1_Spec.md §1.4
// Rust types: generated by prost from d1-doctor-proto (separate repo)
// IMPORTANT: this file must be updated whenever PROTOCOL_VERSION bumps. See §1.0.

export const PROTOCOL_VERSION = 1 as const;

// ─────────────────────────────────────────────────────────────────────────────
// Shared enums / literals
// ─────────────────────────────────────────────────────────────────────────────

export type RiskTier = 'LOW' | 'MEDIUM' | 'HIGH';

export type AgentName =
  | 'planner'
  | 'executor'
  | 'diagnostician'
  | 'reviewer'
  | 'coder'
  | 'researcher';

export type ActionType =
  | 'SHELL'
  | 'FILE_READ'
  | 'FILE_WRITE'
  | 'FILE_MOVE'
  | 'FILE_DELETE'
  | 'PROCESS'
  | 'SYSTEM_INFO'
  | 'WEB_SEARCH';

export type PermissionAction =
  | 'GRANT'
  | 'DENY'
  | 'TIMEOUT_APPROVED'
  | 'TIMEOUT_DENIED';

export type AgentMessageType = 'INFO' | 'WARNING' | 'THINKING';

export type PlanApproveAction = 'APPROVE' | 'MODIFY' | 'REJECT';

export type TaskFailCode =
  | 'UNRECOVERABLE'
  | 'CONNECTION_LOST'
  | 'USER_DENIED'
  | 'PERMISSION_TIMEOUT'
  | 'INTERNAL_ERROR';

export type ErrorCode =
  | 'PROTOCOL_ERROR'
  | 'AUTH_ERROR'
  | 'RATE_LIMITED'
  | 'INTERNAL_ERROR'
  | 'PROTOCOL_VERSION_MISMATCH';

// ─────────────────────────────────────────────────────────────────────────────
// Envelope
// ─────────────────────────────────────────────────────────────────────────────

export interface DaemonEnvelope<T extends string = string, P = unknown> {
  v: typeof PROTOCOL_VERSION;
  id: string;       // UUID4 — unique per message
  ts: number;       // Unix timestamp ms
  type: T;
  payload: P;
}

// ─────────────────────────────────────────────────────────────────────────────
// Outbound payloads  (client → daemon)
// ─────────────────────────────────────────────────────────────────────────────

export interface TaskSubmitPayload {
  task_id: string;
  input: string;
  context: {
    cwd?: string;
    env?: Record<string, string>;
  };
}

export interface TaskCancelPayload {
  task_id: string;
}

export interface PlanStepModification {
  step_id: string;
  description?: string;  // override step description
  skip?: boolean;        // true → send as skipped, Executor will not run it
}

export interface PlanApprovePayload {
  task_id: string;
  plan_id: string;
  action: PlanApproveAction;
  modifications?: PlanStepModification[] | null;
}

export interface PermissionResponsePayload {
  task_id: string;
  permission_id: string;
  action: PermissionAction;
  remember?: boolean;
}

// ─────────────────────────────────────────────────────────────────────────────
// Inbound payloads  (daemon → client)
// ─────────────────────────────────────────────────────────────────────────────

export interface PlanStep {
  step_id: string;
  order: number;
  description: string;
  agent: AgentName;
  risk_tier: RiskTier;
  estimated_seconds?: number;
}

export interface PlanProposedPayload {
  task_id: string;
  plan_id: string;
  summary: string;
  risk_tier: RiskTier;
  steps: PlanStep[];
  requires_approval: boolean;
}

export interface StepStartedPayload {
  task_id: string;
  step_id: string;
  order: number;
  description: string;
  agent: AgentName;
  started_at: number;  // Unix ms
}

export interface StepResult {
  summary: string;
  stdout: string;
  stderr: string;
  exit_code: number;
}

export interface StepCompletedPayload {
  task_id: string;
  step_id: string;
  order: number;
  result: StepResult;
  duration_ms: number;
  credits_used: number;
}

export interface StepError {
  code: string;
  message: string;
  stdout: string;
  stderr: string;
  exit_code: number;
}

export interface StepFailedPayload {
  task_id: string;
  step_id: string;
  order: number;
  error: StepError;
  duration_ms: number;
  diagnostician_triggered: boolean;
}

export interface AgentMessagePayload {
  task_id: string;
  step_id: string;
  agent: AgentName;
  message: string;
  message_type: AgentMessageType;
}

export interface PermissionRequestedPayload {
  task_id: string;
  step_id: string;
  permission_id: string;
  risk_tier: RiskTier;
  action_type: ActionType;
  description: string;
  command_preview?: string;
  remember: boolean;
}

export interface TaskArtifact {
  type: 'file' | 'url' | 'text';
  path?: string;
  url?: string;
  description: string;
}

export interface TaskCompletedPayload {
  task_id: string;
  summary: string;
  steps_completed: number;
  steps_total: number;
  duration_ms: number;
  credits_used: number;
  artifacts?: TaskArtifact[];
}

export interface TaskFailedPayload {
  task_id: string;
  error: {
    code: TaskFailCode;
    message: string;
    failed_step?: string;
    diagnosis?: string;
    steps_completed: number;
    steps_total: number;
  };
  credits_used: number;
}

export interface CreditsUpdatedPayload {
  daily_balance: number;
  bonus_balance: number;
  used_this_task: number;
  reset_at: string;  // ISO 8601
}

export interface DaemonStatusPayload {
  daemon_version: string;
  protocol_version: number;
  orchestrator_connected: boolean;
  orchestrator_url: string;
  active_tasks: number;
  device_id: string;
}

export interface ErrorPayload {
  code: ErrorCode;
  message: string;
  request_id?: string;
  // Only present on PROTOCOL_VERSION_MISMATCH:
  daemon_version?: string;
  supported_protocol_versions?: number[];
}

// ─────────────────────────────────────────────────────────────────────────────
// Discriminated unions — exhaustive type-safe message routing
// ─────────────────────────────────────────────────────────────────────────────

/** All messages that can arrive FROM the daemon */
export type DaemonMessage =
  | DaemonEnvelope<'plan.proposed',        PlanProposedPayload>
  | DaemonEnvelope<'step.started',         StepStartedPayload>
  | DaemonEnvelope<'step.completed',       StepCompletedPayload>
  | DaemonEnvelope<'step.failed',          StepFailedPayload>
  | DaemonEnvelope<'agent.message',        AgentMessagePayload>
  | DaemonEnvelope<'permission.requested', PermissionRequestedPayload>
  | DaemonEnvelope<'task.completed',       TaskCompletedPayload>
  | DaemonEnvelope<'task.failed',          TaskFailedPayload>
  | DaemonEnvelope<'credits.updated',      CreditsUpdatedPayload>
  | DaemonEnvelope<'daemon.status',        DaemonStatusPayload>
  | DaemonEnvelope<'heartbeat',            { pong: true }>
  | DaemonEnvelope<'error',                ErrorPayload>;

/** All messages the client sends TO the daemon */
export type ClientMessage =
  | DaemonEnvelope<'task.submit',          TaskSubmitPayload>
  | DaemonEnvelope<'task.cancel',          TaskCancelPayload>
  | DaemonEnvelope<'plan.approve',         PlanApprovePayload>
  | DaemonEnvelope<'permission.response',  PermissionResponsePayload>
  | DaemonEnvelope<'heartbeat',            { ping: true }>;

// ─────────────────────────────────────────────────────────────────────────────
// Helper — type-safe message factory
// ─────────────────────────────────────────────────────────────────────────────

export function createMessage<T extends ClientMessage['type']>(
  type: T,
  payload: Extract<ClientMessage, { type: T }>['payload'],
): Extract<ClientMessage, { type: T }> {
  return {
    v: PROTOCOL_VERSION,
    id: crypto.randomUUID(),
    ts: Date.now(),
    type,
    payload,
  } as Extract<ClientMessage, { type: T }>;
}

// Usage:
//   const msg = createMessage('task.submit', { task_id: 'tsk_123', input: 'Install OpenClaw', context: {} });
//   ws.send(JSON.stringify(msg));
